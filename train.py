# -*- coding: utf-8 -*-
"""Copy of Maths_Expressions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zxUd6PNCa660l4qSE4GvqXKwm_94-akQ
"""
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv2D, MaxPool2D, Flatten
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import numpy as np
import os
import cv2
import PIL
import matplotlib.pyplot as plt

import os
import augly.image as imaugs
import augly.utils as utils
from IPython.display import display
import random


# Commented out IPython magic to ensure Python compatibility.
# %reload_ext autoreload
# %autoreload

def augment(img):
    blur_img = imaugs.blur(img, output_path='/content/abc_blur.jpg')
    rot_img = imaugs.pad_square(imaugs.rotate(img, degrees=15), color=(255, 255, 255), output_path='/content/abc.jpg')
    rot2_img = imaugs.pad_square(imaugs.rotate(img, degrees=45), color=(255, 255, 255),
                                 output_path='/content/abc_45.jpg')

    # enc_img=imaugs.encoding_quality(img, quality=20)
    # pix_img=imaugs.shuffle_pixels(img, seed=1, factor=0.2)
    # imgs.append(img)
    # imgs.append(blur_img)
    # imgs.append(enc_img)


# new model

from tensorflow.keras.preprocessing import image



def trisect(img):
    image = cv2.imread(img)
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    data = np.asarray(image)
    c = data.shape[1] // 3
    p1 = data[:, :c]
    p2 = data[:, c: 2 * c]
    p3 = data[:, 2 * c:]
    images = [p1, p2, p3]
    new_imgs = []
    for img in images:
        img = np.pad(img, ((13, 14), (13, 14)), 'maximum')
        new_imgs.append(img)
    return new_imgs




def calc(op, n1, n2):
    op = int(op)
    n1 = int(n1)
    n2 = int(n2)
    if op == 10:
        return n1 + n2
    elif op == 11:
        return n1 - n2
    elif op == 12:
        return n1 * n2
    elif n2 != 0:
        return n1 // n2
    else:
        return -100


def eval(img):
    images = trisect(img)
    # plt.imshow(images[0])
    ans = []
    for image in images:
        x = np.expand_dims(image, axis=2)
        # print(x.shape)
        x = np.expand_dims(x, axis=0)
        x = x / 255.0
        y = model.predict(x)
        ans.append(np.argmax(y))
    # print(ans)
    cnt = 0;
    for value in ans:
        if value > 9:
            cnt = cnt + 1
    if not cnt == 1:
        return ('F', -1)
    if ans[0] > 9:
        return ('prefix', calc(ans[0], ans[1], ans[2]))
    elif ans[1] > 9:
        return ('infix', calc(ans[1], ans[0], ans[2]))
    elif ans[2] > 9:
        return ('postfix', calc(ans[2], ans[0], ans[1]))
    else:
        return ('F', -1)



#### imperative  begins ######

###### pre data proceessing  begins
dirs = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'plus', 'minus',
        'times', 'div']
aug_dirs = [x + '_augmented' for x in dirs]
dirs = dirs + aug_dirs
x_train = []  # list of image matrices
y_train = []  # list of one hot encoding of outputs

for i in range(len(dirs)):
    dir_name = 'handwritten-math-symbol-dataset/train/'+dirs[i]
    vec = np.zeros(14)
    vec[i % 14] = 1
    # print(dir_name+' '+str(len(os.listdir(dir_name))))
    for img in os.listdir(dir_name):
        # print(dir_name+'/'+img)
        data = np.asarray(img)
        data = np.resize(data, (155, 155))
        data = np.expand_dims(data, 2)
        # data = np.resize(data,(155,155,1))
        # data=data/255.0
        x_train.append(data)
        y_train.append(vec)

assert (len(x_train) == len(y_train))
x_train = np.array(x_train)
y_train = np.array(y_train)

#### pre data processing neds ####
#print(len(x_train))
#print(len(y_train))

#### final architecture begins ######
model = Sequential()
model.add(Conv2D(32, kernel_size=3, activation='relu', input_shape=(155, 155, 1)))
model.add(Conv2D(64, kernel_size=3, activation='relu'))
model.add(MaxPool2D((2, 2), (2, 2)))
model.add(Conv2D(64, kernel_size=3, activation='relu'))
model.add(Conv2D(64, kernel_size=3, activation='relu'))
model.add(MaxPool2D((4, 4), (4, 4)))
model.add(Conv2D(64, kernel_size=3, activation='relu'))
model.add(MaxPool2D((4, 4), (4, 4)))
model.add(Flatten())
model.add(Dense(14, activation='softmax'))

#### architecture ends##
model.summary()

from tensorflow.keras.optimizers import SGD

sgd = SGD(learning_rate=0.01, decay=1e-6, momentum=0.9, nesterov=True)
model.compile(optimizer=sgd, loss=keras.losses.mean_squared_error, metrics=['accuracy'])

model.fit(x_train, y_train, epochs=100, batch_size=30, validation_split=0.3, shuffle=True)

model.save('final.h5')